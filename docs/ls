// browser-sat.js
//
// A clean DPLL SAT solver for the browser.

export function solveOne(clauses, numVars) {
  const assignment = new Array(numVars + 1).fill(0); // 0=unassigned, 1=true, -1=false

  function isSatisfied(lit) {
    if (lit > 0) return assignment[lit] === 1;
    return assignment[-lit] === -1;
  }

  function dfs() {
    let progress = true;

    while (progress) {
      progress = false;

      for (const clause of clauses) {
        let sat = false;
        let unassigned = [];
        for (const lit of clause) {
          if (isSatisfied(lit)) {
            sat = true;
            break;
          }
          if (assignment[Math.abs(lit)] === 0) unassigned.push(lit);
        }

        if (sat) continue;
        if (unassigned.length === 0) return false;

        if (unassigned.length === 1) {
          const lit = unassigned[0];
          assignment[Math.abs(lit)] = lit > 0 ? 1 : -1;
          progress = true;
        }
      }
    }

    let varToAssign = 0;
    for (let v = 1; v <= numVars; v++) {
      if (assignment[v] === 0) {
        varToAssign = v;
        break;
      }
    }

    if (varToAssign === 0) return true;

    assignment[varToAssign] = 1;
    if (dfs()) return true;

    assignment[varToAssign] = -1;
    if (dfs()) return true;

    assignment[varToAssign] = 0;
    return false;
  }

  const ok = dfs();
  return ok ? assignment : null;
}

// Count **all** solutions (browser-safe bound)
export function solveAll(clauses, numVars, maxSolutions = 1000) {
  const solutions = [];
  const assignment = new Array(numVars + 1).fill(0);

  function isSatisfied(lit) {
    if (lit > 0) return assignment[lit] === 1;
    return assignment[-lit] === -1;
  }

  function dfs() {
    if (solutions.length >= maxSolutions) return;

    let progress = true;
    while (progress) {
      progress = false;

      for (const clause of clauses) {
        let sat = false;
        let unassigned = [];
        for (const lit of clause) {
          if (isSatisfied(lit)) {
            sat = true;
            break;
          }
          if (assignment[Math.abs(lit)] === 0) unassigned.push(lit);
        }

        if (sat) continue;
        if (unassigned.length === 0) return;

        if (unassigned.length === 1) {
          const lit = unassigned[0];
          assignment[Math.abs(lit)] = lit > 0 ? 1 : -1;
          progress = true;
        }
      }
    }

    let varToAssign = 0;
    for (let v = 1; v <= numVars; v++) {
      if (assignment[v] === 0) {
        varToAssign = v;
        break;
      }
    }

    if (varToAssign === 0) {
      solutions.push([...assignment]);
      return;
    }

    assignment[varToAssign] = 1;
    dfs();

    assignment[varToAssign] = -1;
    dfs();

    assignment[varToAssign] = 0;
  }

  dfs();
  return solutions;
}

